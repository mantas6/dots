#!/usr/bin/env php
<?php

// eval each statement in a php file and output diagnostics as json

declare(strict_types=1);

$prog = new class
{
    private array $vars = [];

    private array $diagnostics = [];

    public function handle(): void
    {
        $code = $this->stripTags(stream_get_contents(STDIN));
        $this->evaluate($code);

        echo json_encode($this->diagnostics);
    }

    private function stripTags(string $code): string
    {
        $code = preg_replace_callback('/<\?php\s*/', function ($m) {
            return str_repeat("\n", substr_count($m[0], "\n"));
        }, $code);

        return preg_replace_callback('/\s*\?>/', function ($m) {
            return str_repeat("\n", substr_count($m[0], "\n"));
        }, $code);
    }

    private function evaluate(string $code): void
    {
        $lines = explode("\n", $code);
        $buffer = '';

        foreach ($lines as $i => $line) {
            $lineNum = $i + 1;
            $trimmed = trim($line);

            if ($trimmed === '' || str_starts_with($trimmed, '//') || str_starts_with($trimmed, '#')) {
                continue;
            }

            $buffer .= ($buffer !== '' ? "\n" : '').$line;

            if (! str_contains($buffer, ';')) {
                continue;
            }

            $parts = explode(';', $buffer);
            $buffer = array_pop($parts);

            foreach ($parts as $part) {
                $stmt = trim($part);

                if ($stmt === '') {
                    continue;
                }

                $result = $this->evalStmt($stmt);

                if ($result !== null) {
                    $this->diagnostics[] = [
                        'line' => $lineNum,
                        'message' => $this->format($result),
                    ];
                }
            }
        }
    }

    private function evalStmt(string $stmt): mixed
    {
        try {
            ob_start();
            $result = $this->evalAsExpression($stmt);
            ob_end_clean();

            return $result;
        } catch (\Throwable) {
            ob_end_clean();

            try {
                ob_start();
                $this->evalAsStatement($stmt);
                ob_end_clean();

                return null;
            } catch (\Throwable) {
                ob_end_clean();

                return null;
            }
        }
    }

    private function evalAsExpression(string $stmt): mixed
    {
        $__vars =& $this->vars;
        $__stmt = $stmt;

        return (function () use (&$__vars, $__stmt) {
            extract($__vars, EXTR_REFS);

            $__r = eval("return ($__stmt);");

            $__defined = get_defined_vars();
            unset($__defined['__vars'], $__defined['__r'], $__defined['__stmt'], $__defined['__defined']);

            foreach ($__defined as $__k => $__v) {
                $__vars[$__k] = $__v;
            }

            return $__r;
        })();
    }

    private function evalAsStatement(string $stmt): void
    {
        $__vars =& $this->vars;
        $__stmt = $stmt;

        (function () use (&$__vars, $__stmt) {
            extract($__vars, EXTR_REFS);

            eval("$__stmt;");

            $__defined = get_defined_vars();
            unset($__defined['__vars'], $__defined['__stmt'], $__defined['__defined']);

            foreach ($__defined as $__k => $__v) {
                $__vars[$__k] = $__v;
            }
        })();
    }

    private function format(mixed $value): string
    {
        if (is_string($value)) {
            return "\"$value\"";
        }

        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (is_null($value)) {
            return 'null';
        }

        if (is_array($value)) {
            return json_encode($value);
        }

        return (string) $value;
    }
};

$prog->handle();
