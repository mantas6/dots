#!/usr/bin/env php
<?php

declare(strict_types=1);

require getenv('COMPOSER_HOME').'/vendor/autoload.php';

use PhpParser\Node\Stmt\ClassLike;
use PhpParser\Node\Stmt\Namespace_;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitor\CloningVisitor;
use PhpParser\Parser;
use PhpParser\ParserFactory;
use PhpParser\PrettyPrinter\Standard;

$prog = new class
{
    private Parser $parser;

    private Standard $printer;

    private array $autoloadPaths = [];

    private string $basePath;

    public function __construct()
    {
        $this->parser = (new ParserFactory)->createForNewestSupportedVersion();
        $this->printer = new Standard;
    }

    public function processFilePaths(array $paths): void
    {
        foreach ($paths as $path) {
            $fullPath = realpath($path);
            $this->setupPaths($fullPath);

            $code = file_get_contents($fullPath);

            $code = $this->format($code, $fullPath);

            file_put_contents($fullPath, $code);
        }
    }

    public function processStdin(string $path): void
    {
        $fullPath = realpath($path);
        $this->setupPaths($fullPath);

        $code = stream_get_contents(STDIN);
        $code = $this->format($code, $fullPath);

        echo $code;
    }

    private function setupPaths(string $fullPath): void
    {
        $this->basePath = $this->resolveBasePath($fullPath);
        $this->autoloadPaths = $this->readAutoloadPaths();
    }

    private function format(string $code, string $filePath): string
    {
        if (trim($code) === '') {
            $code = file_get_contents(getenv('DOTS_DIR').'/etc/stubs/PhpClass.stub');
        }

        $relativePath = str_replace($this->basePath.'/', '', $filePath);

        $originalAst = $this->parser->parse($code);
        $originalTokens = $this->parser->getTokens();

        $traverser = new NodeTraverser(new CloningVisitor);
        $ast = $traverser->traverse($originalAst);

        $this->formatAst($ast, $relativePath);

        return $this->printer->printFormatPreserving($ast, $originalAst, $originalTokens);
    }

    private function formatAst(array $ast, string $relativePath): void
    {
        foreach ($ast as $item) {
            if ($item instanceof Namespace_) {
                $item->name->name = $this->convertPathToNamespace($relativePath);

                foreach ($item->stmts as $stmt) {
                    if ($stmt instanceof ClassLike) {
                        $stmt->name->name = str($relativePath)
                            ->afterLast('/')
                            ->chopEnd('.php')
                            ->value();

                        return;
                    }
                }
            }
        }
    }

    private function convertPathToNamespace(string $relativePath): string
    {
        $str = str($relativePath);

        foreach ($this->autoloadPaths as $namespace => $path) {
            $str = $str->replaceStart($path, $namespace);
        }

        return $str->chopEnd('.php')
            ->replace('/', '\\')
            ->beforeLast('\\')
            ->value();
    }

    private function readAutoloadPaths(): array
    {
        $composer = json_decode(
            file_get_contents($this->basePath.'/composer.json'),
            true,
        );

        return [
            ...$composer['autoload']['psr-4'] ?? [],
            ...$composer['autoload-dev']['psr-4'] ?? [],
        ];
    }

    private function resolveBasePath(string $path): string
    {
        if (file_exists("$path/composer.json")) {
            return $path;
        }

        if ($path === '/') {
            throw new Exception('No composer.json has been found');
        }

        return $this->resolveBasePath(
            dirname($path)
        );
    }
};

$params = $argv;
array_shift($params);

if (count($params) && $params[0] === '--stdin') {
    $prog->processStdin($params[1]);
} else {
    $prog->processFilePaths($params);
}
